//  start of  Editor only

//  üèóÔ∏è ed rtt 0  for roadDensity.png
//------------------------------------------------------------------------------------
compositor_node Rtt_RoadDens
{
	in 0 rt_output

	target rt_output
	{
		pass render_scene
		{
			profiling_id "RTT 0 road dens"

			load
			{
				all				clear
				clear_colour	1 0 0 1  // red
			}
			store
			{
				colour	store
				depth	store
				stencil	store
			}
			visibility_mask 0x400  // RV_EdRoadDens  1024
			
			rq_first  70  // road
			rq_last	  72

			overlays	off
		}
	}
}

//  üèóÔ∏è ed rtt 1  for road.png minimap preview
//------------------------------------------------------------------------------------
compositor_node Rtt_RoadPreview
{
	in 0 rt_output

	target rt_output
	{
		pass render_scene
		{
			profiling_id "RTT 1 road prv"

			load
			{
				all				clear
				clear_colour	0 0 0 0  // alpha
			}
			store
			{
				colour	store
				depth	store
				stencil	store
			}
			visibility_mask 0x800  // RV_EdRoadPreview  2048
			
			rq_first  70  // road
			rq_last	  72

			overlays	off
		}
	}
}

//  üèóÔ∏è ed rtt 2  for terrain.jpg minimap preview
compositor_node Rtt_Terrain
{
	in 0 rt_output

	target rt_output
	{
		pass render_scene
		{
			profiling_id "RTT 2 terrain"

			load
			{
				all				clear
				clear_colour	0 0 0 1  // black
			}
			store
			{
				colour	store
				depth	store
				stencil	store
			}
			visibility_mask 4  // RV_Terrain ..
			
			rq_first  11  // terrain
			rq_last	  16

			overlays	off
		}
	}
}

//  üèóÔ∏è ed rtt 3  cam preview  normal all
compositor_node Rtt_View
{
	in 0 rt_output

	target rt_output
	{
		pass render_scene
		{
			profiling_id "RTT 3 view all"

			load
			{
				all				clear
				clear_colour	0 0 0 1  // black
			}
			store
			{
				colour	store
				depth	store
				stencil	store
			}
			visibility_mask	 0x3FF  // normal
			rq_first  0
			rq_last	  199  // before RQ_OVERLAY

			overlays	off
			shadows		SR3_Shadows
			// todo: use that from code, not SR3_Shadows from here
		}
	}
}
//  end of  Editor only


//  üîÆ cube reflections
//------------------------------------------------------------------------------------
abstract target cubemap_target
{
	pass render_scene
	{
		profiling_id "Cube Reflection"

		load
		{
			all				clear
			// clear_colour	1 1 0 1  // test yellow
			clear_colour	0.2 0.4 0.8 1  // skyblue-
		}
		store
		{
			// colour	store
			depth			dont_care
			stencil			dont_care
		}

		expose cubemap

		visibility_mask		0x0000012D  // ..

		overlays			off
		camera_cubemap_reorient true
		// shadows		SR3_Shadows
		// ^ crashes ..
		// todo: use that from code, not SR3_Shadows from here
	}
}

compositor_node CubemapNode
{
	in 0 cubemap

	texture tmpCubemap target_width target_height target_format cubemap mipmaps 0

	target tmpCubemap +X : cubemap_target { }
	target tmpCubemap -X : cubemap_target { }
	target tmpCubemap +Y : cubemap_target { }
	target tmpCubemap -Y : cubemap_target { }
	target tmpCubemap +Z : cubemap_target { }
	target tmpCubemap -Z : cubemap_target { 
		pass ibl_specular
		{
			input tmpCubemap
			output cubemap
	}	}
}

//  not used
// MSAA Cubemaps do not exist. Therefore we have to manually define the RTV (RenderTextureView)
// To render to a temporary MSAA surface and tell Ogre to resolve the MSAA contents into a cubemap
compositor_node CubemapNodeMsaa
{
	in 0 cubemap

	// Note: IF you wish to preserve the MSAA contents of all 6 faces, then use
	//	'texture tmpMsaa target_width target_height 6 target_format 2d_array msaa 4 explicit_resolve'
	// instead
	texture tmpMsaa		target_width target_height target_format msaa 4 explicit_resolve
	texture tmpCubemap	target_width target_height target_format cubemap mipmaps 0

	rtv mixedCubemapRtv
	{
		// Specify we want to render to tmpMsaa at slot[0] but we want to resolve to tmpCubemap
		colour	0 tmpMsaa resolve tmpCubemap
	}

	target mixedCubemapRtv +X : cubemap_target { }
	target mixedCubemapRtv -X : cubemap_target { }
	target mixedCubemapRtv +Y : cubemap_target { }
	target mixedCubemapRtv -Y : cubemap_target { }
	target mixedCubemapRtv +Z : cubemap_target { }
	target mixedCubemapRtv -Z : cubemap_target {
		pass ibl_specular
		{
			input tmpCubemap
			output cubemap
	}	}
}


//------------------------------------------------------------------------------------
//  üèûÔ∏è  Main render  (üë• split screen)
//------------------------------------------------------------------------------------
compositor_node SR3_Render
{
	in 0 rt_renderwindow
	in 1 demo_dynamic_cubemap

	target rt_renderwindow
	{
		pass clear
		{
			profiling_id "Clear all"

			//  executed on first view/eye
			execution_mask			0x01
			//  affected by modifier, apply to the whole screen
			viewport_modifier_mask	0x00

			//  Only write to MSAA surface, don't resolve, overlays legacy problem
			store
			{
				colour	store
				depth	store
				stencil	store
			}
			
			colour_value  0.02 0.015 0.03 1
		}

		//  view render  ----
		pass render_scene
		{
			profiling_id "Main view"

			//  executed in all views/eyes
			execution_mask			0xff
			//  affected by modifier, so renders to a portion of screen
			viewport_modifier_mask	0xff

			// load
			// {
			// 	all			  clear
			// 	clear_colour  0.01 0.01 0.02 1
			// }

			//  Only write to the MSAA surface, don't resolve
			store
			{
				colour	store
				depth	store
				stencil	store
			}
			// store
			// {
			//	colour	store
			// 	// colour	store_or_resolve
			// 	depth	dont_care
			// 	stencil	dont_care
			// }

			//  materials in this pass will be using this cubemap
			expose demo_dynamic_cubemap

			//  used in planar ReflectListener
			identifier	25001

			// in code: game, not ed
			visibility_mask	 0x3FF  // no 1024 ed
			// visibility_mask		0x0000FFFFD  // no hud
			// rq_last		110  // glass,par etc

			overlays	on
			// shadows		SR3_Shadows
		}


		//  restore  ----  for Hud, split
		pass render_scene
		{
			profiling_id "HUD"

			// executed in all eyes, not views
			// execution_mask			0xff
			// executed on first view/eye
			execution_mask			0x01
			// affected by modifier, apply to the whole screen
			viewport_modifier_mask	0x00

			store
			{
				colour	store
				depth	store  //-
				stencil	store
			}
			visibility_mask		0x002  // RV_Hud

			rq_first	200
			rq_last		230

			overlays	off
		}


		// pass custom MYGUI
		// {
			// // provider?  _added in code_
			// profiling_id "GUI"

			// executed in the second eye
			// execution_mask			0x02
			// // not affected by the modifier, apply to the whole screen
			// viewport_modifier_mask	0x00
			
			// rq_first	254
			// rq_last		255
			
			// overlays	on
		// }
	}
}


//  ü™û planar reflections  Water
//------------------------------------------------------------------------------------
compositor_node PlanarReflectionsReflectiveRenderingNode
{
	in 0 rt_renderwindow

	target rt_renderwindow
	{
		pass render_scene
		{
			profiling_id "Planar Reflection"

			load
			{
				all				clear
				clear_colour	0.2 0.4 0.6 1
			}
			store
			{
				colour	store_or_resolve
				depth	dont_care
				stencil	dont_care
			}

			overlays		 off
			visibility_mask  0xfffffffe
			//shadows  SR3_Shadows
		}

		pass generate_mipmaps
		{
			profiling_id "Planar Reflect Mipmaps"
		
			mipmap_method compute_hq
		}
	}
}

workspace PlanarReflectionsReflectiveWorkspace
{
	connect_output PlanarReflectionsReflectiveRenderingNode 0
}


//  üåí shadows  .. drop
//------------------------------------------------------------------------------------
compositor_node_shadow SR3_Shadows
{
	technique pssm

	texture atlas 3072 2048 PFG_D32_FLOAT

	num_splits		3
	pssm_lambda		0.95
	shadow_map 0 atlas uv 0.000000000000000 0.0 0.666666666666667 1.0 light 0 split 0
	shadow_map 1 atlas uv 0.666666666666667 0.0 0.333333333333333 0.5 light 0 split 1
	shadow_map 2 atlas uv 0.666666666666667 0.5 0.333333333333333 0.5 light 0 split 2

	target atlas
	{
		pass clear
		{
			colour_value 1 1 1 1
		}
	}

	shadow_map_target_type directional
	{
		shadow_map 0 1 2
		{
			pass render_scene
			{
				profiling_id "Shadows unused"
			}
		}
	}
}


//  workspace
//------------------------------------------------------------------------------------
workspace SR3_Workspace
{
	// Render Window on channel #0
	connect_external 0 SR3_Render 0
	// Cubemap on channel #1
	connect_external 1 SR3_Render 1
}
